const {Vector2} = require("blockade/vectors");
const {Tiles, Blocks, Plates} = require("blockade/init");
const {Tile, Block, Plate} = require("blockade/entity");

class Blockade {
	constructor() {
		/**
		 * The Set containing all of the Tile instances
		 * @type {Set<Tile>}
		 */
		this.tiles = new Set();
		/**
		 * The Set containing all of the Block instances
		 * @type {Set<Block>}
		 */
		this.blocks = new Set();
		/**
		 * The Set containing all of the Plate instances
		 * @type {Set<Plate>}
		 */
		this.plates = new Set();
		this.minPos = new Vector2();
		this.maxPos = new Vector2();
	}

	minMax(position) {
		if (position.x < this.minPos.x) this.minPos.x = position.x;
		if (position.y < this.minPos.y) this.minPos.y = position.y;
		if (position.x > this.maxPos.x) this.maxPos.x = position.x;
		if (position.y > this.maxPos.y) this.maxPos.y = position.y;
	}

	/**
	 * Add a new Tile at a specific position
	 * @param {TileType} type
	 * @param {Vector2} position
	 * @returns {Tile | undefined}
	 */
	addTile(type, position=new Vector2()) {
		if (type === undefined) return;
		let tile = new Tile(this, position, type);
		this.tiles.add(tile);
		this.minMax(position);
		return tile;
	}

	/**
	 * Add a new Block at a specific position
	 * @param {BlockType} type
	 * @param {Vector2} position
	 * @param {boolean} needTile
	 * @returns {Block | undefined}
	 */
	addBlock(type, position=new Vector2(), needTile=false) {
		if (type === undefined || this.getTile(position) === undefined) return;
		let block = new Block(this, position, type);
		this.blocks.add(block);
		this.minMax(position);
		return block;
	}

	/**
	 * Add a new Plate at a specific position
	 * @param {PlateType} type
	 * @param {Vector2} position
	 * @param {boolean} needTile
	 * @returns {Plate | undefined}
	 */
	addPlate(type, position=new Vector2(), needTile=false) {
		if (type === undefined || this.getTile(position) === undefined) return;
		let plate = new Plate(this, position, type);
		this.plates.add(plate);
		this.minMax(position);
		return plate;
	}

	/**
	 * Get the Tile at a specific position
	 * @param {Vector2} position
	 * @returns {Tile}
	 */
	getTile(position) {
		for (let tile of this.tiles) if (Vector2.equals(tile.position, position)) return tile;
	}

	/**
	 * Get the Block at a specific position
	 * @param {Vector2} position
	 * @returns {Block}
	 */
	getBlock(position) {
		for (let block of this.blocks) if (Vector2.equals(block.position, position)) return block;
	}

	/**
	 * Get the Plate at a specific position
	 * @param {Vector2} position
	 * @returns {Plate}
	 */
	getPlate(position) {
		for (let plate of this.plates) if (Vector2.equals(plate.position, position)) return plate;
	}

	checkWin() {
		if (this.plates.size === 0) return false;
		for (let plate of this.plates) if (!plate.pressed) return false;
		return true;
	}

	canMove(position, direction) {
		let block = this.getBlock(position);
		if (block === undefined) return false;
		return block.canMove(Vector2.fromDirection(direction));
	}

	move(position, direction) {
		let block = this.getBlock(position);
		if (block === undefined) return false;
		return block.setVelocity(Vector2.fromDirection(direction));
	}

	/**
	 * Run a tick for each Entity object
	 */
	tick() {
		for (let tile of this.tiles) tile.tick();
		for (let block of this.blocks) block.tick();
		for (let plate of this.plates) plate.tick();
	}

	/**
	 * Update each Entity object by one turn
	 */
	update() {
		let changed = false;
		for (let tile of this.tiles) changed = tile.update() || changed;
		for (let block of this.blocks) changed = block.update() || changed;
		for (let plate of this.plates) changed = plate.update() || changed;
		return changed;
	}

	render() {
		let str = "";
		for (let y = this.minPos.y; y <= this.maxPos.y; y++) {
			for (let x = this.minPos.x; x <= this.maxPos.x; x++) {
				let pos = new Vector2(x, y);
				if (this.getTile(pos)) {
					str += this.getBlock(pos) ? 'B' : '.';
					str += this.getPlate(pos) ? 'P' : '.';
				} else str += "  ";
				str += ' ';
			}
			str += '\n';
		}
		str += "Victory: " + this.checkWin();
		console.log(str);
	}

	temp() {
		let change = this.update();
		this.render();
		console.log(change);
	}
}

module.exports = {Blockade, Vector2, Tiles, Blocks, Plates};